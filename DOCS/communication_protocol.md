# CFP 通信协议详细设计文档

## 文档概述

本文档详细描述了 CFP 系统中各个组件之间的通信协议，包括 TCP 通信协议和 Redis PUB/SUB 通信协议。

## 当前架构 - 双服务器冗余模式

在当前部署中，系统采用双服务器冗余架构，即一台前端机同时连接主服务器和副服务器。这种模式具有高可用性和调试支持，满足生产环境的稳定性需求。

### TCP 通信协议

#### 服务器端端口

| 端口  | 角色                    | 协议类型 | 内容描述                                      | 数据格式                       |
|-------|-------------------------|----------|-----------------------------------------------|--------------------------------|
| 7000  | 101 监听 (TCP Server)   | 服务端   | 开始检测信号和卷号                            | ASCII 字符 'o' + 卷号字符串    |
| 19800 | 101 监听 (TCP Server)   | 服务端   | 分割定位参数                                  | JSON 格式的参数对象            |

#### 客户端连接

| 端口  | 角色                          | 协议类型 | 内容描述                                      | 数据格式                       |
|-------|-------------------------------|----------|-----------------------------------------------|--------------------------------|
| 19300 | 所有前端机主动连接 (TCP Client) | 客户端   | 特征数据 `'F'` / 状态信息 `'T'`             | ASCII 前缀 + 二进制数据或JSON  |
| 19700 | 101 主动连接 (TCP Client)     | 客户端   | 卷长/宽/速度/卷号/状态（用于服务器界面显示） | JSON 格式的状态对象            |

> 说明：
>
> - `101` 代表主控服务器节点，它既是 TCP 服务端（监听 7000 和 19800 端口），也是 TCP 客户端（连接到 19700 端口）
> - 所有前端机通过 TCP 客户端主动连接到主服务器和副服务器
> - 服务器监听多个端口，分别用于不同类型的指令传输

### 双服务器架构设计

#### 1. 主服务器与副服务器角色

- **主服务器**: 用于生产环境，必须稳定、低延迟
- **副服务器**: 用于调试（如大模型分析），不能影响主服务器的性能
- **故障隔离**: 主服务器和副服务器使用独立的 [asio::io_context](file:///d:/codespace/CFP/third_party/asio/include/asio/io_context.hpp#L61-L64) 确保故障隔离

#### 2. 会话管理

在 [BusinessManager](file:///d:/codespace/CFP/include/business/BusinessManager.hpp#L32-L114) 中，系统维护两组独立的协议会话：

- **主协议会话**:
  - [report_session_](file:///d:/codespace/CFP/include/business/BusinessManager.hpp#L98-L98): 连接到主服务器的 19300 端口（特征数据上报）
  - [telemetry_session_](file:///d:/codespace/CFP/include/business/BusinessManager.hpp#L99-L99): 连接到主服务器的 19700 端口（遥测数据上报）

- **备份协议会话**:
  - [backup_report_session_](file:///d:/codespace/CFP/include/business/BusinessManager.hpp#L102-L102): 连接到副服务器的 19300 端口（特征数据备份）
  - [backup_telemetry_session_](file:///d:/codespace/CFP/include/business/BusinessManager.hpp#L103-L103): 连接到副服务器的 19700 端口（遥测数据备份）

#### 3. 数据发送策略

- **主服务器策略**: 必须成功，失败需重试/告警
- **副服务器策略**: 尽力而为，失败可忽略，绝不阻塞主流程
- **并行发送**: 数据同时异步发送到两个服务器，避免串行阻塞影响实时性

#### 4. 独立网络堆栈

- **main_io_ctx_**: 用于主服务器（生产环境）
- **backup_io_ctx_**: 用于副服务器（调试环境）
- 彻底隔离网络堆栈，避免副服务器影响主线程

### Redis 通信协议

在当前部署中，系统使用 Redis 作为分布式通信中间件，用于同步多台机器之间的状态和控制信号。

#### Redis PUB/SUB 通道

| 通道名称           | 发布者      | 订阅者      | 内容描述                       | 数据格式    |
|-------------------|-------------|-------------|--------------------------------|-------------|
| control_signals   | 主控节点    | 所有前端机  | 控制信号（开始/停止检测等）     | JSON 对象   |
| telemetry_data    | 所有前端机  | 主控节点    | 遥测数据（状态、性能指标等）   | JSON 对象   |
| config_updates    | 主控节点    | 所有前端机  | 配置更新                       | JSON 对象   |

#### Redis 键值存储

| 键名                    | 类型      | 用途描述                     | 数据格式    |
|------------------------|-----------|------------------------------|-------------|
| camera_status:*        | Hash      | 相机状态信息                 | Hash 对象   |
| system_config          | String    | 系统配置                     | JSON 字符串 |
| last_detection_result  | String    | 最后检测结果                 | JSON 字符串 |

## 未来架构 - 多相机模式

当系统升级为多相机配置时，所有相机均在同一主机上运行，因此无需依赖 Redis 进行跨主机变量同步。

### 多相机架构通信

在多相机模式下，系统架构将简化为：

1. **本地通信**: 相机之间通过共享内存或队列进行通信
2. **统一控制**: 通过 [MultiCameraCoordinator](file:///d:/codespace/CFP/include/MultiCameraCoordinator.hpp#L1-L33) 统一管理多个相机
3. **集中处理**: 所有图像数据在本地进行处理和融合

## 通信协议实现

### TCP 通信实现

TCP 通信协议由以下组件实现：

- [AsioTcpTransport](file:///d:/codespace/CFP/include/protocol/AsioTcpTransport.hpp#L1-L35): 基于 ASIO 库的 TCP 传输层
- [ProtocolSession](file:///d:/codespace/CFP/include/protocol/ProtocolSession.hpp#L1-L31): 通信会话管理
- [TransportAdapter](file:///d:/codespace/CFP/include/protocol/TransportAdapter.hpp#L1-L17): 传输层适配器

### Redis 通信实现

Redis 通信协议由以下组件实现：

- [IRedisClient](file:///d:/codespace/CFP/include/redis/IRedisClient.hpp#L1-L9): Redis 客户端接口
- [RedisClient](file:///d:/codespace/CFP/include/redis/RedisClient.hpp#L1-L17): Redis 客户端具体实现
- 分布式状态同步模块

## 状态机设计

### 客户端状态机

```
[初始状态] 
    ↓ (连接服务器)
[连接中] 
    ↓ (连接成功)
[已连接] 
    ↓ (开始检测命令)
[检测中] 
    ↓ (检测完成/手动停止)
[已停止] 
    ↓ (断开连接)
[断开中] 
    ↓ (断开完成)
[初始状态]
```

### 服务端状态机

```
[初始状态]
    ↓ (启动服务)
[监听中] (监听端口 7000, 19800)
    ↓ (接收连接)
[连接处理中]
    ↓ (接收检测结果)
[结果处理中]
    ↓ (处理完成)
[监听中]
```

## 错误处理与恢复

### 连接错误处理

1. **连接超时**: 实现重连机制，最多重试 5 次，每次间隔 2 秒
2. **数据传输错误**: 使用校验和验证数据完整性
3. **服务端宕机**: 自动切换到备用服务器（如果配置了）

### Redis 连接错误处理

1. **Redis 连接失败**: 尝试连接备用 Redis 实例
2. **PUB/SUB 消息丢失**: 实现消息确认机制
3. **键值存储异常**: 使用本地缓存作为降级方案

## 性能优化

### TCP 通信优化

1. **连接池**: 复用 TCP 连接，减少连接建立开销
2. **批量传输**: 将多个小数据包合并传输，提高传输效率
3. **压缩算法**: 对大数据包进行压缩传输

### Redis 优化

1. **管道操作**: 批量执行 Redis 命令
2. **过期策略**: 设置合理的键过期时间，避免内存泄漏
3. **持久化配置**: 根据数据重要性选择合适的持久化策略

## 安全考虑

### TCP 安全

1. **IP 白名单**: 限制连接来源 IP
2. **数据加密**: 对敏感数据进行加密传输
3. **认证机制**: 实现连接认证，防止非法接入

### Redis 安全

1. **访问控制**: 设置 Redis 密码认证
2. **网络隔离**: 将 Redis 部署在内网，限制外部访问
3. **权限管理**: 为不同应用分配不同的 Redis 权限

## 监控与日志

### 通信监控

1. **连接状态监控**: 实时监控 TCP 连接状态
2. **消息统计**: 统计发送/接收的消息数量和频率
3. **性能指标**: 监控延迟、吞吐量等性能指标

### 日志记录

1. **通信日志**: 记录所有通信事件和状态变化
2. **错误日志**: 详细记录通信错误和异常情况
3. **性能日志**: 记录通信性能数据，用于分析优化

## IPC通信协议

### IPC崩溃信息传输协议

CFP系统实现了专门的IPC崩溃信息传输协议，用于在崩溃发生时快速、安全地将崩溃信息发送到监控服务器。

#### UDP崩溃信息格式

崩溃信息通过UDP协议发送，格式如下：

```
CRASH pid=<进程ID> tid=<线程ID> code=<异常代码> addr=<崩溃地址>
```

或

```
CRASH pid=<进程ID> tid=<线程ID> code=<异常代码> (<异常描述>) addr=<崩溃地址>
```

#### IPC配置参数

| 参数 | 默认值 | 描述 |
|------|--------|------|
| ipc_server_ip | 127.0.0.1 | IPC服务器IP地址 |
| ipc_server_port | 5141 | IPC服务器端口 |
| ipc_protocol | udp | IPC通信协议 (tcp/udp) |
| ipc_send_enabled | false | 是否启用IPC日志传输 |

#### 崩溃信息传输流程

1. 崩溃发生时，触发SEH异常处理
2. 收集崩溃基本信息（进程ID、线程ID、异常代码、崩溃地址）
3. 通过UDP协议发送最小崩溃信息到IPC服务器
4. 生成Minidump文件到本地
5. 安全退出进程

## 崩溃处理通信协议

### 客户端-服务器崩溃处理架构

CFP采用工业级崩溃处理架构，将崩溃处理分为客户端和服务器端两个部分：

1. **客户端职责**：
   - 捕获崩溃事件
   - 生成Minidump文件
   - 通过UDP发送最小崩溃信息
   - 立即安全退出进程

2. **服务器端职责**：
   - 接收上传的Minidump文件
   - 使用调试符号（PDB）进行详细分析
   - 生成崩溃报告
   - 进行崩溃统计和去重

### 崩溃信息内容

客户端发送的最小崩溃信息包含：

- 进程ID（pid）
- 线程ID（tid）
- 异常代码（ExceptionCode）
- 崩溃地址（崩溃位置）
- 时间戳
- Build ID/Git Hash

服务器端进行详细分析时使用：

- Minidump文件
- 对应版本的PDB文件
- 符号服务器
